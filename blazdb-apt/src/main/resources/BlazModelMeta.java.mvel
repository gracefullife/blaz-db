package @{packageName};

import net.vvakame.blaz.Entity;
import net.vvakame.blaz.Key;
import net.vvakame.blaz.meta.ModelMeta;
import net.vvakame.blaz.meta.KeyAttributeMeta;
import net.vvakame.blaz.meta.PropertyAttributeMeta;


/**
 * Meta class for {@link @{target}}.<br>
 * This class generated by BlazDB.
 * @author vvakame
 */
public class @{target}@{postfix} extends ModelMeta<@{target}> {

	static final String KIND = "@{kind}";
	
	static final @{target}@{postfix} singleton = new @{target}@{postfix}();

	final KeyAttributeMeta @{primaryKey.name} = new KeyAttributeMeta(KIND);

@foreach{attr : attributes}@if{attr.primitiveWrapper != null}
	final PropertyAttributeMeta<@{attr.primitiveWrapper}> @{attr.name} = new PropertyAttributeMeta<@{attr.primitiveWrapper}>("@{attr.name}", @{attr.primitiveWrapper}.class);
@else{}
	final PropertyAttributeMeta<@{attr.typeNameFQN}> @{attr.name} = new PropertyAttributeMeta<@{attr.typeNameFQN}>("@{attr.name}", @{attr.typeNameFQN}.class);
@end{}@end{}

	protected @{target}@{postfix}() {
		super(null);
	}
	
    /**
     * @return the singleton
     */
	public static @{target}@{postfix} get() {
		return singleton;
	}

	@Override
	public void setKey(@{target} model, Key key) {
		model.@{primaryKey.setter}(key);
	}

	@Override
	public Key getKey(@{target} model) {
		return model.@{primaryKey.getter}();
	}

	@Override
	public String getKind() {
		return KIND;
	}

	@Override
	public Class<@{target}> getModelClass() {
		return @{target}.class;
	}

	@Override
	public Entity modelToEntity(@{target} model) {
		if (model == null) {
			throw new NullPointerException("model is required");
		}

		Key key = getKey(model);
		Entity entity;
		if (key != null) {
			entity = new Entity(key);
		} else {
			entity = new Entity(KIND);
		}

@foreach{attr : attributes}
		entity.setProperty("@{attr.name}", model.@{attr.getter}());
@end{}

		return entity;
	}
	
	@Override
	public @{target} entityToModel(Entity entity) {
		if (entity == null) {
			throw new NullPointerException("entity is required");
		} else if (!KIND.equals(entity.getKind())) {
			throw new IllegalArgumentException("entity kind=" + entity.getKind() + ", but expected=" + KIND);
		}

		/*
		List<String> classHierarchy = entity.getProperty(PROPERTY_CLASS_HIERARCHY);
		if (classHierarchy == null) {
			// ok. only root node.
		} else if (classHierarchyList.size() < classHierarchy.size()) {
			// if entity is lower model...
			String className = classHierarchy.get(classHierarchy.size() - 1);
			ModelMeta<Object> meta = DatastoreUtil.getModelMeta(className);
			if (!meta.getKind().equals(entity.getKind())) {
				throw new IllegalArgumentException("kind=" + entity.getKind() + " is not expected.");
			}
			return (RootData) meta.entityToModel(entity);
		} else if (classHierarchyList.size() > classHierarchy.size()) {
			// if entity is upper model. can't convert to model...
			throw new IllegalArgumentException(
					"entity is not convert to model. check class hierarchy.");
		}
		 */

		Key key = entity.getKey();
		@{target} model = new @{target}();
		setKey(model, key);
		
@foreach{attr : attributes}@if{attr.typeNameFQN == "boolean" || attr.typeNameFQN == "char"}
		model.@{attr.setter}((@{attr.primitiveWrapper}) entity.getProperty("@{attr.name}"));
@else{attr.primitiveWrapper != null}
		model.@{attr.setter}(((Number) entity.getProperty("@{attr.name}")).@{attr.typeNameFQN}Value());
@else{}
		model.@{attr.setter}((@{attr.typeNameFQN}) entity.getProperty("@{attr.name}"));
@end{}@end{}

		return model;
	}
}
