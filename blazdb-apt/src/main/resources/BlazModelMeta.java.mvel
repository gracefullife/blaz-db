package @{packageName};

import java.util.List;
import java.util.ArrayList;

import net.vvakame.blaz.Entity;
import net.vvakame.blaz.Key;
import net.vvakame.blaz.meta.ModelMeta;
import net.vvakame.blaz.meta.KeyAttributeMeta;
import net.vvakame.blaz.meta.PropertyAttributeMeta;


/**
 * Meta class for {@link @{target}}.<br>
 * This class generated by BlazDB.
 * @author vvakame
 */
public class @{target}@{postfix} extends ModelMeta<@{target}> {

	static final String KIND = "@{kind}";
	
	private static final @{target}@{postfix} __singleton = new @{target}@{postfix}();

	final KeyAttributeMeta @{primaryKey.name} = new KeyAttributeMeta(KIND);

@foreach{attr : attributes}
@if{attr.isNumberPrimitive()}
	final PropertyAttributeMeta<@{attr.castTo}> @{attr.name} = new PropertyAttributeMeta<@{attr.castTo}>("@{attr.name}", @{attr.castTo}.class);
@elseif{attr.isNumberPrimitiveWrapper()}
	final PropertyAttributeMeta<@{attr.typeNameFQN}> @{attr.name} = new PropertyAttributeMeta<@{attr.typeNameFQN}>("@{attr.name}", @{attr.typeNameFQN}.class);
@elseif{attr.castTo != null}
	final PropertyAttributeMeta<@{attr.castTo}> @{attr.name} = new PropertyAttributeMeta<@{attr.castTo}>("@{attr.name}", @{attr.castTo}.class);
@else{}
	final PropertyAttributeMeta<@{attr.typeNameFQNWithGenerics}> @{attr.name} = new PropertyAttributeMeta<@{attr.typeNameFQNWithGenerics}>("@{attr.name}", @{attr.typeNameFQN}.class);
@end{}@end{}

	final List<PropertyAttributeMeta<?>> __properties;
	
	protected @{target}@{postfix}() {
		super(null);

		__properties = new ArrayList<PropertyAttributeMeta<?>>();
@foreach{attr : attributes}
		__properties.add(@{attr.name});
@end{}
	}
	
	/**
	 * @return the singleton
	 */
	public static @{target}@{postfix} get() {
		return __singleton;
	}

	@Override
	public void setKey(@{target} model, Key key) {
		model.@{primaryKey.setter}(key);
	}

	@Override
	public Key getKey(@{target} model) {
		return model.@{primaryKey.getter}();
	}

	@Override
	public String getKind() {
		return KIND;
	}

	@Override
	public Class<@{target}> getModelClass() {
		return @{target}.class;
	}
	
	@Override
	public List<PropertyAttributeMeta<?>> getProperties() {
		return __properties;
	}

	@Override
	public Entity modelToEntity(@{target} model) {
		if (model == null) {
			throw new NullPointerException("model is required");
		}

		Key key = getKey(model);
		Entity entity;
		if (key != null) {
			entity = new Entity(key);
		} else {
			entity = new Entity(KIND);
		}

@foreach{attr : attributes}
		entity.setProperty("@{attr.name}", model.@{attr.getter}());
@end{}

		entity.setProperty("@{schemaVersionName}", @{schemaVersion});

		return entity;
	}
	
	@Override
	public @{target} entityToModel(Entity entity) {
		if (entity == null) {
			throw new NullPointerException("entity is required");
		} else if (!KIND.equals(entity.getKind())) {
			throw new IllegalArgumentException("entity kind=" + entity.getKind() + ", but expected=" + KIND);
		}

		/*
		List<String> classHierarchy = entity.getProperty(PROPERTY_CLASS_HIERARCHY);
		if (classHierarchy == null) {
			// ok. only root node.
		} else if (classHierarchyList.size() < classHierarchy.size()) {
			// if entity is lower model...
			String className = classHierarchy.get(classHierarchy.size() - 1);
			ModelMeta<Object> meta = DatastoreUtil.getModelMeta(className);
			if (!meta.getKind().equals(entity.getKind())) {
				throw new IllegalArgumentException("kind=" + entity.getKind() + " is not expected.");
			}
			return (RootData) meta.entityToModel(entity);
		} else if (classHierarchyList.size() > classHierarchy.size()) {
			// if entity is upper model. can't convert to model...
			throw new IllegalArgumentException(
					"entity is not convert to model. check class hierarchy.");
		}
		 */

		Key key = entity.getKey();
		@{target} model = new @{target}();
		setKey(model, key);
		
@foreach{attr : attributes}
		if(entity.hasProperty("@{attr.name}")) {
	@if{attr.isNumberPrimitive()}
			model.@{attr.setter}(((Number) entity.getProperty("@{attr.name}")).@{attr.typeNameFQN}Value());
	@else{attr.isNumberPrimitiveWrapper()}
			Number value = entity.getProperty("@{attr.name}");
			if(value == null) {
				model.@{attr.setter}(null);
			} else {
				model.@{attr.setter}(value.@{attr.castTo}Value());
			}
	@else{attr.castTo != null}
			model.@{attr.setter}((@{attr.castTo}) entity.getProperty("@{attr.name}"));
	@else{attr.kind() == "LIST" && attr.subKind() == "BYTE_WRAPPER"}
			model.@{attr.setter}(toByteList(entity, "@{attr.name}"));
	@else{attr.kind() == "LIST" && attr.subKind() == "SHORT_WRAPPER"}
			model.@{attr.setter}(toShortList(entity, "@{attr.name}"));
	@else{attr.kind() == "LIST" && attr.subKind() == "INT_WRAPPER"}
			model.@{attr.setter}(toIntegerList(entity, "@{attr.name}"));
	@else{attr.kind() == "LIST" && attr.subKind() == "FLOAT_WRAPPER"}
			model.@{attr.setter}(toFloatList(entity, "@{attr.name}"));
	@else{attr.kind() == "LIST"}
			model.@{attr.setter}(toList(@{attr.subTypeNameFQN}.class, entity, "@{attr.name}"));
	@else{}
			model.@{attr.setter}((@{attr.typeNameFQNWithGenerics}) entity.getProperty("@{attr.name}"));
	@end{}
		}
@end{}

		return model;
	}
}
